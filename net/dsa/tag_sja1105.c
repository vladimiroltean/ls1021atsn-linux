// SPDX-License-Identifier: GPL-2.0
/* Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
 */
#include <linux/if_vlan.h>
#include <linux/dsa/sja1105.h>
#include <linux/packing.h>
#include "dsa_priv.h"

static bool sja1105_can_tstamp(const struct sk_buff *skb,
			       struct net_device *dev)
{
	return sja1105_is_link_local(skb);
}

static bool sja1105_filter(const struct sk_buff *skb, struct net_device *dev)
{
	if (sja1105_is_meta_frame(skb)) {
		SJA1105_SKB_CB(skb)->type = SJA1105_FRAME_TYPE_META;
		return true;
	}
	if (sja1105_is_link_local(skb)) {
		SJA1105_SKB_CB(skb)->type = SJA1105_FRAME_TYPE_LINK_LOCAL;
		return true;
	}
	if (!dev->dsa_ptr->vlan_filtering)
		return true;
	return false;
}

static struct sk_buff *sja1105_xmit(struct sk_buff *skb,
				    struct net_device *netdev)
{
	struct dsa_port *dp = dsa_slave_to_port(netdev);
	struct dsa_switch *ds = dp->ds;
	u16 tx_vid = dsa_tagging_tx_vid(ds, dp->index);
	u8 pcp = skb->priority;

	/* Transmitting management traffic does not rely upon switch tagging,
	 * but instead SPI-installed management routes.
	 */
	if (unlikely(sja1105_is_link_local(skb))) {
		dsa_defer_xmit(skb, netdev);
		/* Let DSA free its reference to the skb and we will free
		 * the clone in the deferred worker
		 */
		return NULL;
	}

	/* If we are under a vlan_filtering bridge, IP termination on
	 * switch ports based on 802.1Q tags is simply too brittle to
	 * be passable. So just defer to the dsa_slave_notag_xmit
	 * implementation.
	 */
	if (dp->vlan_filtering)
		return skb;

	return dsa_8021q_xmit(skb, netdev, ETH_P_EDSA,
			     ((pcp << VLAN_PRIO_SHIFT) | tx_vid));
}

/* This is a simple state machine (the state is kept in the private structure
 * of struct dsa_port) which follows the hardware mechanism of generating RX
 * timestamps: after each timestampable skb (all traffic for which send_meta1
 * and send_meta0 is true, therefore all MAC-filtered link-local traffic) a
 * meta frame containing a partial timestamp is immediately generated by the
 * switch and sent as a follow-up to the link-local frame on the CPU port.
 * This function pairs the link-local frame with its partial timestamp from the
 * meta follow-up frame. The full timestamp will be reconstructed in a delayed
 * work context.
 */
static struct sk_buff *sja1105_rcv_meta_state_machine(struct sk_buff *skb)
{
	struct sja1105_port *sp;
	struct dsa_port *dp;

	dp = dsa_slave_to_port(skb->dev);
	sp = dp->priv;

	if (SJA1105_SKB_CB(skb)->type & SJA1105_FRAME_TYPE_META) {
		struct sja1105_skb_cb *cb;

		/* Was this a meta frame instead of the link-local
		 * that we were expecting?
		 */
		if (!sp->expect_meta) {
			/* If timestamping is not enabled on this port and
			 * we're still receiving meta frames, it must have been
			 * requested on other ports. But since the send_meta
			 * setting is global for the switch, receiving a meta
			 * frame at this point is not really unexpected, but
			 * nonetheless useless. So just discard it and don't
			 * print anything to the user in that case.
			 */
			if (sp->hwts_rx_en)
				dev_err_ratelimited(dp->ds->dev,
						    "Unexpected meta frame\n");
			return NULL;
		}

		sp->expect_meta = false;
		/* Copy the timestamp from the meta frame
		 * into the cached skb.
		 */
		cb = SJA1105_SKB_CB(sp->last_stampable_skb);
		cb->meta_tstamp = SJA1105_SKB_CB(skb)->meta_tstamp;
		set_bit(SJA1105_STATE_META_ARRIVED, &cb->state);
		/* Drop the meta frame from further processing up the stack */
		skb = NULL;
	} else if ((SJA1105_SKB_CB(skb)->type &
		    SJA1105_FRAME_TYPE_LINK_LOCAL) && sp->hwts_rx_en) {
		/* Was this a link-local frame instead of the meta
		 * that we were expecting?
		 */
		if (sp->expect_meta)
			dev_err_ratelimited(dp->ds->dev,
					    "Expected meta frame\n");

		sp->expect_meta = true;
		/* Let this frame be forwarded on the switch port, queued by
		 * dsa_skb_defer_rx_timestamp and reinjected in the stack by
		 * sja1105_port_rxtstamp_work once we also receive the meta
		 * frame.
		 */
		SJA1105_SKB_CB(skb)->orig_time = ktime_get();
		/* Hold a reference so that we avoid the
		 * sja1105_port_rxtstamp_work freeing it from under our feet.
		 */
		skb_unref(sp->last_stampable_skb);
		sp->last_stampable_skb = skb_get(skb);
	}

	return skb;
}

static struct sk_buff *sja1105_rcv(struct sk_buff *skb,
				   struct net_device *netdev,
				   struct packet_type *pt)
{
	struct ethhdr *hdr = eth_hdr(skb);
	u64 source_port, switch_id;
	struct sk_buff *nskb;
	u16 tpid, vid, tci;
	bool is_tagged;
	u64 tstamp;

	nskb = dsa_8021q_rcv(skb, netdev, pt, &tpid, &tci);
	is_tagged = (nskb && tpid == ETH_P_EDSA);

	skb->priority = (tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
	vid = tci & VLAN_VID_MASK;

	skb->offload_fwd_mark = 1;

	if (SJA1105_SKB_CB(skb)->type & SJA1105_FRAME_TYPE_META) {
		u8 *meta = skb_mac_header(skb) + ETH_HLEN;

		/* UM10944 4.2.17 AVB Parameters:
		 * Structure of the meta-data follow-up frame
		 */
		packing(meta,     &tstamp,     23, 0, 4, UNPACK, 0);
		packing(meta + 6, &source_port, 7, 0, 1, UNPACK, 0);
		packing(meta + 7, &switch_id,   7, 0, 1, UNPACK, 0);
		if (is_tagged)
			dump_stack();

		SJA1105_SKB_CB(skb)->meta_tstamp = tstamp;

	} else if (SJA1105_SKB_CB(skb)->type & SJA1105_FRAME_TYPE_LINK_LOCAL) {
		/* Management traffic path. Switch embeds the switch ID and
		 * port ID into bytes of the destination MAC, courtesy of
		 * the incl_srcpt options.
		 */
		source_port = hdr->h_dest[3];
		switch_id = hdr->h_dest[4];
		/* Clear the DMAC bytes that were mangled by the switch */
		hdr->h_dest[3] = 0;
		hdr->h_dest[4] = 0;
	} else {
		/* Normal traffic path. */
		source_port = dsa_tagging_rx_source_port(vid);
		switch_id = dsa_tagging_rx_switch_id(vid);
	}

	skb->dev = dsa_master_find_slave(netdev, switch_id, source_port);
	if (!skb->dev) {
		netdev_warn(netdev, "Couldn't decode source port\n");
		return NULL;
	}

	/* Delete/overwrite fake VLAN header, DSA expects to not find
	 * it there, see dsa_switch_rcv: skb_push(skb, ETH_HLEN).
	 */
	if (is_tagged)
		memmove(skb->data - ETH_HLEN, skb->data - ETH_HLEN - VLAN_HLEN,
			ETH_HLEN - VLAN_HLEN);

	return sja1105_rcv_meta_state_machine(skb);
}

const struct dsa_device_ops sja1105_netdev_ops = {
	.xmit = sja1105_xmit,
	.rcv = sja1105_rcv,
	.filter = sja1105_filter,
	.can_tstamp = sja1105_can_tstamp,
	.overhead = VLAN_HLEN,
};

