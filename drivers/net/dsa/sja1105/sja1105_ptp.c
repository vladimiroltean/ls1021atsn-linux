// SPDX-License-Identifier: GPL-2.0
/* Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
 */
#include <linux/spi/spi.h>
#include "sja1105.h"

/* The adjfine API clamps ppb between [-32,768,000, 32,768,000], and
 * therefore scaled_ppm between [-2,147,483,648, 2,147,483,647].
 * Set the maximum supported ppb to a round value smaller than the maximum.
 *
 * Percentually speaking, this is a +/- 0.032x adjustment of the
 * free-running counter (0.968x to 1.032x).
 */
#define SJA1105_MAX_ADJ_PPB		32000000
#define SJA1105_SIZE_PTP_CMD		4

/* PTPSYNCTS has no interrupt or update mechanism, because the intended
 * hardware use case is for the timestamp to be collected synchronously,
 * immediately after the CAS_MASTER SJA1105 switch has triggered a CASSYNC
 * pulse on the PTP_CLK pin. When used as a generic extts source, it needs
 * polling and a comparison with the old value. The polling interval is just
 * the Nyquist rate of a canonical PPS input (e.g. from a GPS module).
 * Anything of higher frequency than 1 Hz will be lost, since there is no
 * timestamp FIFO.
 */
#define SJA1105_EXTTS_INTERVAL		(HZ / 2)

/*            This range is actually +/- SJA1105_MAX_ADJ_PPB
 *            divided by 1000 (ppb -> ppm) and with a 16-bit
 *            "fractional" part (actually fixed point).
 *                                    |
 *                                    v
 * Convert scaled_ppm from the +/- ((10^6) << 16) range
 * into the +/- (1 << 31) range.
 *
 * This forgoes a "ppb" numeric representation (up to NSEC_PER_SEC)
 * and defines the scaling factor between scaled_ppm and the actual
 * frequency adjustments of the PHC.
 *
 *   ptpclkrate = scaled_ppm * 2^31 / (10^6 * 2^16)
 *   simplifies to
 *   ptpclkrate = scaled_ppm * 2^9 / 5^6
 */
#define SJA1105_CC_MULT_NUM		(1 << 9)
#define SJA1105_CC_MULT_DEM		15625
#define SJA1105_CC_MULT			0x80000000

/* The PTP_CLK pin may be configured to toggle with a 50% duty cycle and a
 * frequency f:
 *
 *           NSEC_PER_SEC
 * f = ----------------------
 *     (PTPPINDUR * 8 ns) * 2
 */
#define SJA1105_HZ_TO_PIN_DURATION(hz) (NSEC_PER_SEC / (16 * hz))

#define ptp_to_sja1105(d) container_of((d), struct sja1105_private, ptp_caps)
#define ew_to_sja1105(d) container_of((d), struct sja1105_private, extts_work)

int sja1105_get_ts_info(struct dsa_switch *ds, int port,
			struct ethtool_ts_info *info)
{
	struct sja1105_private *priv = ds->priv;

	/* Called during cleanup */
	if (!priv->clock)
		return -ENODEV;

	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
				SOF_TIMESTAMPING_RX_HARDWARE |
				SOF_TIMESTAMPING_RAW_HARDWARE;
	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
			 (1 << HWTSTAMP_TX_ON);
	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
			   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT);
	info->phc_index = ptp_clock_index(priv->clock);
	return 0;
}

int sja1105et_ptp_cmd(const void *ctx, const void *data)
{
	const struct sja1105_ptp_cmd *cmd = data;
	const struct sja1105_private *priv = ctx;
	const struct sja1105_regs *regs = priv->info->regs;
	const int size = SJA1105_SIZE_PTP_CMD;
	u8 buf[SJA1105_SIZE_PTP_CMD] = {0};
	/* No need to keep this as part of the structure */
	u64 valid = 1;

	sja1105_pack(buf, &valid,           31, 31, size);
	sja1105_pack(buf, &cmd->startptpcp, 28, 28, size);
	sja1105_pack(buf, &cmd->stopptpcp,  27, 27, size);
	sja1105_pack(buf, &cmd->resptp,      2,  2, size);
	sja1105_pack(buf, &cmd->corrclk4ts,  1,  1, size);
	sja1105_pack(buf, &cmd->ptpclkadd,   0,  0, size);

	return sja1105_spi_send_packed_buf(priv, SPI_WRITE, regs->ptp_control,
					   buf, SJA1105_SIZE_PTP_CMD);
}

int sja1105pqrs_ptp_cmd(const void *ctx, const void *data)
{
	const struct sja1105_ptp_cmd *cmd = data;
	const struct sja1105_private *priv = ctx;
	const struct sja1105_regs *regs = priv->info->regs;
	const int size = SJA1105_SIZE_PTP_CMD;
	u8 buf[SJA1105_SIZE_PTP_CMD] = {0};
	/* No need to keep this as part of the structure */
	u64 valid = 1;

	sja1105_pack(buf, &valid,           31, 31, size);
	sja1105_pack(buf, &cmd->startptpcp, 28, 28, size);
	sja1105_pack(buf, &cmd->stopptpcp,  27, 27, size);
	sja1105_pack(buf, &cmd->resptp,      3,  3, size);
	sja1105_pack(buf, &cmd->corrclk4ts,  2,  2, size);
	sja1105_pack(buf, &cmd->ptpclkadd,   0,  0, size);

	return sja1105_spi_send_packed_buf(priv, SPI_WRITE, regs->ptp_control,
					   buf, SJA1105_SIZE_PTP_CMD);
}

/* The switch returns partial timestamps (24 bits for SJA1105 E/T, which wrap
 * around in 0.135 seconds, and 32 bits for P/Q/R/S, wrapping around in 34.35
 * seconds).
 *
 * This receives the RX or TX MAC timestamps, provided by hardware as
 * the lower bits of the cycle counter, sampled at the time the timestamp was
 * collected.
 *
 * To reconstruct into a full 64-bit-wide timestamp, the cycle counter is
 * read and the high-order bits are filled in.
 *
 * Must be called within one wraparound period of the partial timestamp since
 * it was generated by the MAC.
 */
u64 sja1105_tstamp_reconstruct(struct sja1105_private *priv, u64 now,
			       u64 ts_partial)
{
	u64 partial_tstamp_mask = CYCLECOUNTER_MASK(priv->info->ptp_ts_bits);
	u64 ts_reconstructed;

	ts_reconstructed = (now & ~partial_tstamp_mask) | ts_partial;

	/* Check lower bits of current cycle counter against the timestamp.
	 * If the current cycle counter is lower than the partial timestamp,
	 * then wraparound surely occurred and must be accounted for.
	 */
	if ((now & partial_tstamp_mask) <= ts_partial)
		ts_reconstructed -= (partial_tstamp_mask + 1);

	return ts_reconstructed;
}

/* Reads the SPI interface for an egress timestamp generated by the switch
 * for frames sent using management routes.
 *
 * SJA1105 E/T layout of the 4-byte SPI payload:
 *
 * 31    23    15    7     0
 * |     |     |     |     |
 * +-----+-----+-----+     ^
 *          ^              |
 *          |              |
 *  24-bit timestamp   Update bit
 *
 *
 * SJA1105 P/Q/R/S layout of the 8-byte SPI payload:
 *
 * 31    23    15    7     0     63    55    47    39    32
 * |     |     |     |     |     |     |     |     |     |
 *                         ^     +-----+-----+-----+-----+
 *                         |                 ^
 *                         |                 |
 *                    Update bit    32-bit timestamp
 *
 * Notice that the update bit is in the same place.
 * To have common code for E/T and P/Q/R/S for reading the timestamp,
 * we need to juggle with the offset and the bit indices.
 */
int sja1105_ptpegr_ts_poll(struct sja1105_private *priv, int port, u64 *ts)
{
	const struct sja1105_regs *regs = priv->info->regs;
	int tstamp_bit_start, tstamp_bit_end;
	int timeout = 10;
	u8 packed_buf[8];
	u64 update;
	int rc;

	do {
		rc = sja1105_spi_send_packed_buf(priv, SPI_READ,
						 regs->ptpegr_ts[port],
						 packed_buf,
						 priv->info->ptpegr_ts_bytes);
		if (rc < 0)
			return rc;

		sja1105_unpack(packed_buf, &update, 0, 0,
			       priv->info->ptpegr_ts_bytes);
		if (update)
			break;

		usleep_range(10, 50);
	} while (--timeout);

	if (!timeout)
		return -ETIMEDOUT;

	/* Point the end bit to the second 32-bit word on P/Q/R/S,
	 * no-op on E/T.
	 */
	tstamp_bit_end = (priv->info->ptpegr_ts_bytes - 4) * 8;
	/* Shift the 24-bit timestamp on E/T to be collected from 31:8.
	 * No-op on P/Q/R/S.
	 */
	tstamp_bit_end += 32 - priv->info->ptp_ts_bits;
	tstamp_bit_start = tstamp_bit_end + priv->info->ptp_ts_bits - 1;

	*ts = 0;

	sja1105_unpack(packed_buf, ts, tstamp_bit_start, tstamp_bit_end,
		       priv->info->ptpegr_ts_bytes);

	return 0;
}

int sja1105_ptp_reset(struct sja1105_private *priv)
{
	struct sja1105_ptp_cmd cmd = priv->ptp_cmd;
	int rc;

	mutex_lock(&priv->ptp_lock);

	cmd.resptp = 1;

	dev_dbg(priv->ds->dev, "Resetting PTP clock\n");
	rc = priv->info->ptp_cmd(priv, &cmd);

	mutex_unlock(&priv->ptp_lock);

	return rc;
}

static int sja1105_ptp_gettimex(struct ptp_clock_info *ptp,
				struct timespec64 *ts,
				struct ptp_system_timestamp *sts)
{
	struct sja1105_private *priv = ptp_to_sja1105(ptp);
	u64 ticks;

	mutex_lock(&priv->ptp_lock);

	ticks = sja1105_ptpclkval_read(priv, sts);
	*ts = ns_to_timespec64(sja1105_ticks_to_ns(ticks));

	mutex_unlock(&priv->ptp_lock);

	return 0;
}

/* Caller must hold priv->ptp_lock */
static inline int sja1105_ptp_mode_set(struct sja1105_private *priv,
				       enum sja1105_ptp_clk_mode mode)
{
	if (priv->ptp_cmd.ptpclkadd == mode)
		return 0;

	priv->ptp_cmd.ptpclkadd = mode;

	return priv->info->ptp_cmd(priv, &priv->ptp_cmd);
}

/* Caller must hold priv->ptp_lock */
static inline int sja1105_ptpclkval_write(struct sja1105_private *priv,
					  u64 val)
{
	const struct sja1105_regs *regs = priv->info->regs;

	return sja1105_spi_send_int(priv, SPI_WRITE, regs->ptpclk, &val, 8,
				    NULL);
}

/* Write to PTPCLKVAL while PTPCLKADD is 0 */
static int sja1105_ptp_settime(struct ptp_clock_info *ptp,
			       const struct timespec64 *ts)
{
	u64 ticks = ns_to_sja1105_ticks(timespec64_to_ns(ts));
	struct sja1105_private *priv = ptp_to_sja1105(ptp);
	int rc;

	mutex_lock(&priv->ptp_lock);

	rc = sja1105_ptp_mode_set(priv, PTP_SET_MODE);
	if (rc < 0) {
		dev_err(priv->ds->dev, "Failed to put PTPCLK in set mode\n");
		goto out;
	}

	rc = sja1105_ptpclkval_write(priv, ticks);

out:
	mutex_unlock(&priv->ptp_lock);

	return rc;
}

static int sja1105_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
{
	struct sja1105_private *priv = ptp_to_sja1105(ptp);
	const struct sja1105_regs *regs = priv->info->regs;
	s64 clkrate;
	int rc;

	clkrate = (s64)scaled_ppm * SJA1105_CC_MULT_NUM;
	clkrate = div_s64(clkrate, SJA1105_CC_MULT_DEM);

	/* Take a +/- value and re-center it around 2^31. */
	clkrate = SJA1105_CC_MULT + clkrate;
	clkrate &= GENMASK_ULL(31, 0);

	mutex_lock(&priv->ptp_lock);

	rc = sja1105_spi_send_int(priv, SPI_WRITE, regs->ptpclkrate,
				  &clkrate, 4, NULL);

	mutex_unlock(&priv->ptp_lock);

	return rc;
}

/* Caller must hold priv->ptp_lock */
u64 sja1105_ptpclkval_read(struct sja1105_private *priv,
			   struct ptp_system_timestamp *sts)
{
	const struct sja1105_regs *regs = priv->info->regs;
	u64 ptpclkval = 0;
	int rc;

	rc = sja1105_spi_send_int(priv, SPI_READ, regs->ptpclk,
				  &ptpclkval, 8, sts);
	if (rc < 0)
		dev_err_ratelimited(priv->ds->dev,
				    "failed to read ptp time: %d\n",
				    rc);

	return ptpclkval;
}

/* Write to PTPCLKVAL while PTPCLKADD is 1 */
static int sja1105_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
	struct sja1105_private *priv = ptp_to_sja1105(ptp);
	s64 ticks = ns_to_sja1105_ticks(delta);
	int rc;

	mutex_lock(&priv->ptp_lock);

	rc = sja1105_ptp_mode_set(priv, PTP_ADD_MODE);
	if (rc < 0) {
		dev_err(priv->ds->dev, "Failed to put PTPCLK in add mode\n");
		goto out;
	}

	rc = sja1105_ptpclkval_write(priv, ticks);

out:
	mutex_unlock(&priv->ptp_lock);

	return rc;
}

static void sja1105_ptp_extts_work(struct work_struct *work)
{
	struct delayed_work *dw = to_delayed_work(work);
	struct sja1105_private *priv = ew_to_sja1105(dw);
	const struct sja1105_regs *regs = priv->info->regs;
	struct ptp_clock_event event;
	u64 ptpsyncts = 0;
	int rc;

	mutex_lock(&priv->ptp_lock);

	rc = sja1105_spi_send_int(priv, SPI_READ, regs->ptpsyncts,
				  &ptpsyncts, 8, NULL);
	if (rc < 0)
		dev_err_ratelimited(priv->ds->dev,
				    "Failed to read PTPSYNCTS: %d\n", rc);

	if (ptpsyncts && priv->ptpsyncts != ptpsyncts) {
		event.index = 0;
		event.type = PTP_CLOCK_EXTTS;
		event.timestamp = ns_to_ktime(sja1105_ticks_to_ns(ptpsyncts));
		ptp_clock_event(priv->clock, &event);

		priv->ptpsyncts = ptpsyncts;
	}

	mutex_unlock(&priv->ptp_lock);

	schedule_delayed_work(&priv->extts_work, SJA1105_EXTTS_INTERVAL);
}

static int sja1105_pps_enable(struct sja1105_private *priv, bool on)
{
	const struct sja1105_regs *regs = priv->info->regs;
	struct sja1105_ptp_cmd cmd = priv->ptp_cmd;
	struct timespec64 ts;
	u64 ptp_pin_duration;
	u64 ptp_pin_start;
	u64 ticks;
	u64 now;
	int rc;

	if (priv->extts_input)
		return -EOPNOTSUPP;

	mutex_lock(&priv->ptp_lock);

	if (on) {
		/* Align to the start of the first second that begins
		 * 0.5 seconds from now, to give us time to program
		 * the switch.
		 */
		ticks = sja1105_ptpclkval_read(priv, NULL);
		now = sja1105_ticks_to_ns(ticks);

		ts = ns_to_timespec64(now + NSEC_PER_SEC / 2);
		ts.tv_nsec = 0;
		ts.tv_sec += 1;

		ptp_pin_start = timespec64_to_ns(&ts) / 8;
		ptp_pin_duration = SJA1105_HZ_TO_PIN_DURATION(1);

		rc = sja1105_spi_send_int(priv, SPI_WRITE, regs->ptppinst,
					  &ptp_pin_start, 8, NULL);
		if (rc < 0)
			goto out;

		rc = sja1105_spi_send_int(priv, SPI_WRITE, regs->ptppindur,
					  &ptp_pin_duration, 4, NULL);
		if (rc < 0)
			goto out;
	}

	if (on)
		cmd.startptpcp = true;
	else
		cmd.stopptpcp = true;

	rc = priv->info->ptp_cmd(priv, &cmd);

out:
	mutex_unlock(&priv->ptp_lock);

	return rc;
}

static int sja1105_extts_enable(struct sja1105_private *priv, bool on)
{
	if (!priv->extts_input)
		return -EOPNOTSUPP;

	if (on)
		schedule_delayed_work(&priv->extts_work,
				      SJA1105_EXTTS_INTERVAL);
	else
		cancel_delayed_work_sync(&priv->extts_work);

	return 0;
}

static int sja1105_ptp_enable(struct ptp_clock_info *ptp,
			      struct ptp_clock_request *rq, int on)
{
	struct sja1105_private *priv = ptp_to_sja1105(ptp);
	int rc = -EOPNOTSUPP;

	if (rq->type == PTP_CLK_REQ_PPS)
		rc = sja1105_pps_enable(priv, on);
	else if (rq->type == PTP_CLK_REQ_EXTTS &&
		 rq->extts.index == 0)
		rc = sja1105_extts_enable(priv, on);

	return rc;
}

int sja1105_ptp_clock_register(struct sja1105_private *priv)
{
	struct dsa_switch *ds = priv->ds;

	priv->ptp_caps = (struct ptp_clock_info) {
		.owner		= THIS_MODULE,
		.name		= "SJA1105 PHC",
		.adjfine	= sja1105_ptp_adjfine,
		.adjtime	= sja1105_ptp_adjtime,
		.gettimex64	= sja1105_ptp_gettimex,
		.settime64	= sja1105_ptp_settime,
		.enable		= sja1105_ptp_enable,
		.max_adj	= SJA1105_MAX_ADJ_PPB,
	};

	if (priv->extts_input)
		priv->ptp_caps.n_ext_ts = 1;
	else
		priv->ptp_caps.pps = 1;

	mutex_init(&priv->ptp_lock);

	priv->clock = ptp_clock_register(&priv->ptp_caps, ds->dev);
	if (IS_ERR_OR_NULL(priv->clock))
		return PTR_ERR(priv->clock);

	INIT_DELAYED_WORK(&priv->extts_work, sja1105_ptp_extts_work);

	priv->ptp_cmd.corrclk4ts = true;
	priv->ptp_cmd.ptpclkadd = PTP_SET_MODE;

	return sja1105_ptp_reset(priv);
}

void sja1105_ptp_clock_unregister(struct sja1105_private *priv)
{
	if (IS_ERR_OR_NULL(priv->clock))
		return;

	cancel_delayed_work_sync(&priv->extts_work);
	ptp_clock_unregister(priv->clock);
	priv->clock = NULL;
}
